Селективность индекса - насколько хорошо он уменьшает выборку.
Скажем, создавать индекс по полу при равномерном распределении полов - тупо.

Запись - логический уровень.

Touple - физический уровень.
TID - Touple ID. #page: offset.

Записи могут иметь версии, это тоже Touple. Конкретная транзакция видит только один соответствующий Touple.

Индекс не содержат инфы о видимости.

При обновлении записи - появляется новая запись в индексе.
Index bloat

Индекс может использоваться для where, ordery by, order by col opr value??

При конкурентном создании индексов, он может создастся не сразу.
Т.е. в какой-то момент запросы будут юзать Full Scan.

Для GIN индексов порядок столбцов не важен.

Типы должны точно совпадать с типом индекса(в предикатах).
Иногда для этого нужно делать Cast.

Индексы могут поддерживать не все операторы??

Bitmap при поиске - в отсортированном виде.
А ещё, если поиск идет по двум столбцам - битовая маска позволяет проводить бинарные операции.
Допустим, у нас есть несколько индексов. И мы получили битмапы для каждого.

GiST, GIN, SP-GiST поддерживают пользовательские типы данных для хранения индексов.

Стандарта для работы с индексами пока нет.

При создании индекса можно USING method (B-tree, Hash, Gis, GIN, Sp-GIS).

\d pg_am - список методов.

# storage_parameter

* B-Tree, GiST - FILLFACTOR (степень заполненности страницы) (ReadOnly - 100%).
* GIN - FASTUPDATE (on by default) Ускоряет вставку, но немного тормозит поиск.

TABLESPACE - можно завести индексы на отдельном диске. Можно запараллеливать чтение и запись.

opclass - ?? оператор для колонки ??

ASC/DESC - порядок сортировки (помнить сортировки по умолчанию).
Очень хорошо, чтобы соответствовал ORDER BY.


Без CONCURRENTLY - CREATE INDEX лочит таблицу.
Ждет окончания всех транзакций. И два прохода.

Нельзя создавать в транзакции.


Функциональный индекс.

Ф-и нельзя менять состояние базы.
Т.е. можно использовать sin(x) при индексации, и тогда при матчинге если заюзаешь sin(x) - то будет использоваться индекс и синус считаться не будет.


====

Мониторинг индексов.

Что используется и как.


Пересечение индексов - например по первой колонке и по двум первым.

Для работы с индексами - посмотри ODF с презентацией.


SET maintenance_work_mem 'x MB', чем больше - тем быстрее создается индекс.

Когда делаешь тесты бенчмарки, выключай всякие службы, типа vacuum, это можно делать в параметрах запроса (autovacuum_enabled = off).


CLUSTER - упорядочивание таблицы как Index - уменьшает кол-во блоков для чтения.

Круто, когда есть ORDER BY и LIMIT

OFFSET - не всегда хорошо.

Если ORDER BY a,b хорошо если индекс тоже a, b

**HEAP** - физическое хранилище, туплы.


Можно настраивать оптимизатор, задавать косты для разные операций.

Seq Page, Random Page.


Можно прямо при запросе управлять выбором планов.

**Есть утилита plantuner.**

Есть pg_hint_plan.

Есть частичные индексы.

?? Head (Heap ??) Only Tuple (HOT)

KNN - GIST ускорение поиска ближайших соседей.

Кстати, эту геометрию можно юзать на сайте.


Пока нет партиций.





















