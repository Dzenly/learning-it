http://www.postgresql.org/docs/9.4/static/transaction-iso.html
http://www.postgresql.org/docs/9.4/static/sql-set-transaction.html

SQL стандарт определяет 4 уровня изоляции транзакций. Наиболее строгий - *Serializable*, он требует, чтобы при одновременном выполнении множества транзакций эффект был такой, как если бы они выполнялись последовательно.

Различные явления, запрещенные на разных уровнях:

### Dirty read

Одна транзакция читает изменения, внесенные *незакоммиченной* другой транзакцией.

### Nonrepeatable read

Два одинаковых чтения в одной транзакции дают разные результаты, из-за другой *закоммиченной* транзакции.

### phantom read

При двух одинаковых чтениях результат содержит разное количество строк из-за другой транзакции.

Согласно стандарту SQL:
В скобках - разрешенные явления.

* Serializable (No)
* Repeatable read (Phantom read)
* Read commited (Nonrepeatable read, phantom read)
* Read uncommited (Dirty read, nonrepeatable read, phantom read)

Реально в ПГ

* Serializable (No)
* Repeatable read (No)
* Read commited (Nonrepeatable read) (**Default**)
* Read uncommited (Dirty read, nonrepeatable read)


ПГ 9.4 не поддерживает Read uncommited, в этом случае он использует Read commited и не поддерживает phantom read.

Некоторые ПГ data types и функции имеют правила относительно поведения в транзакциях.

?? In particular, changes made to a sequence (and therefore the counter of a column declared using serial) are immediately visible to all other transactions and are not rolled back if the transaction that made the changes aborts. See Section 9.16 and Section 8.1.4.

## Read Commited

Дефолтный уровень в ПГ. 
SELECT (Без FOR UPDATE/SHARE) видит только данные, закоммиченные перед исполнением query. ??
Не видит незакоммиченные данные конкурирующих транзакций.
Не видит изменения  конкурирующих транзакций закоммиченные после начала выполнения SELECT.
SELECT видит состояние базы на момент, когда запрос начинает выполняться.
Однако, SELECT видит изменения исполненные в рамках своей транзакции, даже если они ещё не закоммичены.
Два последовательных SELECT могут видеть разные данные, даже в пределах одной транзакции, если другие транзакции закоммитили изменения, сделанные между SELECT'ами. 

UPDATE, DELETE, SELECT FOR UPDATE, SELECT FOR SHARE - при поиске целевых строк ведут себя как SELECT :

Они видят только строки, которые были закомичены на момент старта команды. 
Однако, такая строка может быть обновлена или удалена или заблокирована к тому моменту, когда она нашлась.
В этом случае, потенциальный обновитель (вторая транзакция) будет ждать пока первая транзакция не завершится (коммитом или ролбэком).
При ролбэке вторая транзакция будет работать с уже найденными строками. При коммите - она будет игнорить строки, удаленные первой транзакцией. И будет пытаться применить операции к обновленной версии строки.
Условие поиска (WHERE) будет перевычисленно, чтобы понять соответствует ли новая строка условиям поиска. Если да, вторая транзакция использует обновленную версию строки. В случаях SELECT FOR UPDATE/SHARE лочиться и возвращаться клиенту будет обновленная версия строки.


Для обновляющей команды возможно видеть неконсистентный снэпшот: она может видеть эффекты от конкурентных апдейтов строки, которую сама хочет обновить. Но она не видит эффекты на других строках. Это не позволяет использовать Read Commited для сложных условий поиска, однако нормально работает в простых поисках.

```sql
BEGIN;
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 1;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 2;
COMMIT;
```

Если две такие транзакции хотят изменить баланс аккаунта 1, мы хотим, чтобы вторая транзакция запустилась с обновленной версией строки.
Т.к. каждая команда трогает конкретную строку им можно позволять видеть обновленные версии.

----------

### 	Нежелательное поведение для сложных случаев

Допустим, website - это таблица из двух строк где hits равно 9 и 10.

```
BEGIN;
UPDATE website SET hits = hits + 1;
-- run from another session:  DELETE FROM website WHERE hits = 10;
COMMIT;
```
Если hits = 9 - строка пропускается.
Если hits = 10, DELETE ждет пока закончится апдейт, и hits становится 11.

Т.к. Read Commited запускает каждую команду с новым снапшотом, который включает все закоммиченные транзакции на этот момент, последующие
команды этой транзакции будут видеть обновления закомиченные другими транзакциями.
Смысл ситуации выше в том, консистентное ли состояние базы, когда его видит **конкретная** команда транзакции.

Read Commited достаточно быстрый и подходит для многих приложений с простыми запросами. Но в сложных запросах часто нужен уровень построже.

## Repeatable Read

Видит данные, закомиченные перед началом транзакции.
Т.е. не_видит незакоммиченных изменений и закоммиченных после начала транзакции.
Видит свои изменения, даже незакоммиченные.

Этот уровень у PG строже, чем минимально требует SQL стандарт, т.к. запрещает и Phantom Read.

Read Commited - видит слепок базы на момент старта запроса внутри транзакции, а Repeatable Read - слепок на момент начала транзакции.

Если применяешь этот уровень - обрабатывай ошибки сериализации и повторяй транзакцию.

UPDATE, DELETE, SELECT FOR UPDATE/SHARE - тоже видят слепок на момент начала транзакции.
Однако строки могут быть обновлены, удалены, или залочены конкурентной транзакцией к моменту, когда строки нашлись.
Если конкуррентная транзакция откатилась - ок, как будто её и не было.
Если закоммитилась и обновила или удалила строки (а не просто залочила), тогда будет ошибка сериализации:

ERROR:  could not serialize access due to concurrent update

И нужно будет повторить транзакцию.
?? Есть ли авто-повтор ??

Read-only транзакции не имеют проблем сериализации.

Слепок базы может быть неконсистентным с сериализованными транзакциями того же уровня.
Read-only транзакции могут видеть контрольные записи, обновленные, чтобы показать что batch завершен, но не видят детали записей, которые связанные с этим batch, т.к. они читают предыдущую ревизию. ?? Муть ??

Этот уровень изоляции может потребовать ручных локов, для нормальной работы.

## Serializable

Транзакции выполняются, как если бы они шли последовательно, а не параллельно.
Тоже бывают serialization failures. 
Работает так же как Repeatable Read, но мониторит условия, которые приводят к неконсистентности. ?? Дедлоки ??
Введение мониторинга не добавляет блокировок, по сравнению с Repeatable Read, но требует некоторых расходов, на обнаружение аномалий сериализации.








https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9


https://msdn.microsoft.com/en-us/library/ms378149.aspx

