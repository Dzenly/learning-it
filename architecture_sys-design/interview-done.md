https://www.youtube.com/watch?v=J_Ad9BG84oI&t=2s

URL shortening.
Авторедирект.

Сначала нужно оформить требования и цели.

URL должен быть уникальным.
Как долго должны жить?
Неугадываемые линки.

Ограничения.
Уточнения терминов.
Нагрузка.

Как часто будут меняться требования.

Latency
Throughput

Consistency
Availability

* Weak Consistency
* Eventual Consistency
* Strong Consistency

=========

# Fail Over
* Active-Passive

Active-Active

Availability в процентах.
Сколько процентов времени можно быть в дауне.
Например 1%, значит 3.5 дня в году.

Нагрузка.
Чтения. Записи.

Маштабирование

Pessimistic write (блокировка, но надежность)
Optimistic write - ошибка, что есть. И если что перегенерить.


Вертикальное масштабирование - Latency.
Горизонтальное масштабирование - Throughput.
Если много слабых машин - запрос будет медленно обрабатываться.
Важно и то и то.

DNS - два адреса, для масштабирования?
Кэшируется на клиенте.
Есть TTL.
Плохо конфигурируется. Плохо работает.

CDN - статический контент.

CSS, HTML, JS, JPG.

push CDNs, pull CDN.
Платные.

python - однопоточное приложение.

Reverse Proxy + Компрессия + TLS сертификат.

# Load Balancer.

* Checks for healthy servers.
* Checks for loading of servers.
* Session persistence.
I.e. use cookies and route specific client to the same instance of web app.


Точка отказа.
Добавляет сложность.

Можно добавить ещё LB. Теоретически можно добавить в DNS оба лоад балансера.

Горизонтальное масштабирование.
Сервера должны быть stateless.

Разделение на микросервисов.

Монолит проще деплоить.

============

* RDBMS
* k/v store
* Document store
* Graph db
* Time series db

============

# Replication
master-slave
master-master

много реплик - есть replication lag.
conflict resolution master меняется.

# Federation

Разделяем сущности по разным БД.
Но сложно тогда работать с таблицами, что надо с кучей серверов одновременно работать, джойнить данные.

# Partitioning

Данные раскладываем по разным таблицам.

* Multi-column List Partitioning (разные колонки по разным таблицам).
* Automatic List Partitioning (строки ?). Например, каждый месяц новая партиция.

# Sharding

Одна таблица раскладывается по разным серверам.
Недостатки: логика приложения должна поддерживать работу с шардами,
сложные SQL запросы.
Может быть разбалансировка шардов.
Ребалансинг вносит сложность.
Требует больше железа.

# Денормализация

Хранение кучи данных.

==================

Consistent hashing (DynamoDB, Cassandra)
Где нода знает что в соседних нодах хранится.
И так по кругу.

==================

# Cache

* Client (browser)
* CDN
* Web Server
* DB (View)
* App (оперативная память приложения)
* DB query
* object


## Cache Aside
* App (одновременно пишет данные и в кэш и в БД).
Читает сначала кэш, а если нет - БД и запись в кэш.
* Если нода упала, то все пойдет в кэш заново.

## Write-through
При чтении в кэш не заносим.

## Write-behind (write-back)
Пишем в кэш.
А отдельный процесс потом это заливает в БД.
Можем потерять данные при сбоях.

## Refresh-ahead
* Периодически обновляем кэш.
Например токены.
Экспарится - получаем заново.
Недостатки - юзер может видеть старые данные.

## Read-through

============

# Asyncronism

Чистка. Рассылка.













==================




















============


















