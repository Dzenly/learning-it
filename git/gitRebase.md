http://habrahabr.ru/post/161009/

Позволяет делать fast-forward при подсасывании ваших изменений.



checkout feature
rebase master

работает так:

* находит общий родительский коммит для веток.
* идет в текущей ветке по коммитам, вычисляет патч между смежными коммитами, пытается применить его к текущему состоянию master.
* если ок - создается коммит Комм1.
* указатели master и feature остаются на месте, но HEAD перемещается но новый коммит (detached HEAD)
* ORIG_HEAD - старая голова на feature.
* дальше следующий патч прикладывается к Комм1, допустим, возник конфликт.
* тогда rebase останавливается, оставляя состояние detached HEAD (git status это выдаст).
* Все изменения, внесенные патчем находятся в рабочей копии.
* Неконфликтующие изменения подготовлены к коммиту (?? staged ??)

Дальше можно пойти следующими путями:

##  Отменить rebase (git rebase --abort)

HEAD перенесется на feature. Добавленные коммиты останутся без указателей на них, и вскоре будут удалены (?? когда).

## Разрулить конфликт.

Затем:

git add fname
git rebase --continue

Если все ок, создастся коммит Комм2, и перейдем к следующему патчу.


## Если изменения в ветвях являются полностью взаимоисключающими и правильный в master.

То при разруливании конфликтов патча не останется (изменений в рабочей копии не будет) и git rebase --continue ругнется.

git rebase --skip - пропустит создание коммита


---

дальше, допустим следущий патч наложился без конфликтов, создался последний коммит.

указатель feature переходит на последний коммит.
HEAD переходит на feature.

rebase окончен. старые коммиты больше не нужны.

Коммиты, созданные при rebase будут содержать имя автора старого коммита и дату Author*
А также имя ребейзера и дату: Commit*.


========================

На самом деле веток 4:

master, origin/master, feature, origin/feature.


