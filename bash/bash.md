Есть неких POSIX стандарт для шеллов.

Команда

var1=34 comm args

echo -e '1\n2'

Есть опции начинающиеся с символа +

В классическом UNIX не было полноименных опций --xxxx, это особенность GNU.

Как только встретился аргумент, которые не опция, считается, что дальше
идут не опции.

```
alexey@dzen:~$ echo -e '1\n2' -f
1
2 -f
```

```
> dev/null - избавление от вывода.
$? - результат команды (число)
```

LANG=en_EN_UTF-8 command - язык для команды.

?? #0 что означает запись?

ls file/ - символ слэш задает каталог (а не файл)

Шелл обрабатывает всякие экраны до отправки в команду.

-- - означает, что опций больше нет.

ls -li -- -* - выдаст номер.

```
find -inum <number> -exec rm {} \;
```

dd - правильно копирует поврежденные сектора, в отличие от cp.

read A - ввод в переменную A (с клавиатуры, из файла, как придется)
Читает из файла до символа конца строки.

```sh
# Считать и вывести весь файл.
while read A; do echo $A; done </some/file
# В конце read вылетает с ошибкой, поэтому while заканчивается.
```

& в конце - открепить процесс от терминала.

=============

```
ls s*.*[g] - все файлы, начинающиеся на s и кончается на g.

# Диапазон [0-9]
```

?? Какие ещё есть спецсимволы.

shopt -s extglob

```
ls *.iso *.docx
ls !(*.iso|*.docx)

ls +([0-9])

# ! - не
# + - один или более
# ?
# * - ноль или более
# @ - один из
# | - или внутри скобок

# {} - перебор элементов
# touch filename{1,2,3}.txt
  
cat {a,b}/{c,d} # Пробелы нельзя.
cat: a/c: No such file or directory
cat: a/d: No such file or directory
cat: b/c: No such file or directory
cat: b/d: No such file or directory

```

history - история комманд с их номерами.

!492 - подставить 492 из истории.

!ki - поиск по первым символам.

!! - подставить последнюю команду

# Ctrl

* R - ищет в обратной истории.
* A - начало строки.
* E - конец строки
* L - очистить экран
* U - удалить все перед курсором
* K - удалить все после курсора
* B - слово назад
* F - слово вперед



?? Есть ли в баше хелп по этим Ctrl ??

# Alt

. (точка) - последний аргумент команды в истории
Если ещё раз нажать точку - пред предыдущий последний аргумент команды.
(т.е. всегда последний)
Если у команды нет аргументов - то последний аргумент - это она сама.


=================

Подмена строки в предыдущей команде.
^ls^rm^

Утилита **file** - инфа о файле по заголовку файла (а не по расширению).

Tab - команду ищет по PATH.
Агрумент ищет в текущем каталоге??

cd -
вернуться в предыдущий каталог.

bash-completion - кастомные правила для команды.

======

Диапазон в последних версиях bash (грозит потерей совместимости со старыми версиями)
touch fname{1..3}.txt

======

0 код ошибки.

$? - код возврата предыдущей команды.

exit - закончить сессию shell код
если нет кода, будет юзаться код предыдущей команды.

Ветвления: && || !

**Договорились что 0 это ИСТИНА, а остальные значения - ложь.**

&& не выполняет правую часть, если левая уже косячнулась.
Работает как then.

**Это здорово для чайнинга, когда последующая команда бессмысленна для сломанной предыдущей**.


|| - тоже, если первая часть true - вторая часть не выполняется.
Работает как else.

```
cd /folder || echo 'Can not enter to folder'
cd /folder || (echo 'Can not enter to folder';exit 1) # иначе общий результат будет TRUE.

# () - группирует команды.

# && (логическое умножение) приоритетней || (логическое сложение).

command args && echo OK || echo FAIL

Если команда выполнится, то пойдет &&, если команда не выполнится && не пойдет, но пойдет ||.

```

===============================

# test

Это бинарник, присутствующий в системе.

**man test**

```sh
A=5;test "A" == '1'; echo $?
1

A=5; test "$A" == 5; echo $?
0

# Пробелы важны, т.к. test это команда, и аргументы команды должны быть разделены пробелами.
```

?? Зачем кавычки ??
?? Что означают разные типы кавычек ??


?? Все переменные - это строки ??

== != > < - сравнение строк.
**Сначала сравнивается количество символов, а потом коды ??**

?? Операции перенаправления ввода клэшатся с операциями больше меньше ??

```sh
alexey@dzen:~/tmp1$ test asdf "<" aaaaa ; echo $?
1
alexey@dzen:~/tmp1$ test asdf ">" aaaaa ; echo $?
0
```

Для чисел:

-eq
-gt
-lt
-le

# [

Работает как команда test, но требует последним аргументом ]

which [
/usr/bin/[
alexey@dzen:~/tmp1$ which ]
alexey@dzen:~/tmp1$ 

```
"c" ">" "b" ] && [ 5 -lt  4 ]; echo $?
```

# [[

Похоже, это уже команда, а не утилита.

```sh
[[ 6 -gt 5 && 5 -lt  6 ]]; echo $?
```

Но со строками не проканает.

```sh
[[ "c" ">" "b" && 5 -lt  6 ]]; echo $?
# bash: conditional binary operator expected
# bash: syntax error near `">"'

[[ ( "c" ">" "b" ) && 5 -lt  6 ]]; echo $?

# bash: conditional binary operator expected
# bash: expected `)'
# bash: syntax error near `">"'
```

## Двойные круглые скобки - для работы с числами.

Строка, которая не может преобразоваться в число - преобразуется в 0.

## if then else

```
if [  ]; then ; else ; fi
```

Можно подмешивать любые команды с ; между if, then, else, if ...,
т.к. интерпретатор будет ориентироваться по этим ключевым словам.
Есть elif.

**В интерпретаторе Enter обрабатывается специфично для команды, скажем для if, он не будет выпонять команду, а просто перейдет на следующую строку**

# case in / esac

```sh
A=1
case "$A" in
1) echo asd; asdf;asdf;asdf ;;
2) asdf asdf ;;
*) echo 'Default' ;;
# ;; значит - перейти на esac

# ;;& - перейти на следующее, если сравнение успешно.

# ;;& - перейти если условие не успешно тоже.

esac
```

Причем, поддерживаются wild cards:

```sh
*asd.e*asd*
```

===============================

# Регулярные выражения (=~)

```
if [[ "$A" =~ T.eexp.]]
```

В кавычках пишем "$A", чтобы учесть пустое значение и чтобы учесть пробелы.
Но тоже может обломаться, в некоторых средах, тогда можно так:

```
if [ "x$A" == "x$B"]
```

?? Чем отличаются двойные от одиночных кавычек ??

===============================

# Переменные.

Только строка, и только целое число.

3.1415 - строка.

С плавающей точкой работают awk, bc, perl.

Пробелы юзать низя.

A = 2 - выполняется команда А с двумя аргументами.

A= 2 - выполняется присваивание пустого значения переменной A, а потом вполняется команда 2.

**При первом обращении к переменной - если её нет, она создастся.**

присваивание пустого значения:
```
A= 
```

Присвоение переменной без команды - вводит эту переменную на всю сессию bash.

===============================

# set - все переменные.

# env экспортируемые переменные.





===============================









