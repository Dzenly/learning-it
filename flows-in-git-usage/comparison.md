# По каким параметрам имеет смысл сравнивать подходы к ветвлению

* Кол-во мерж конфликтов.
* Кол-во работы с git при запиливании фич.
* Может ли масштабироваться с ростом команды.
*


# Git Flow

* main - Основная ветка для прода (напрямую коммиты не делаются).
* develop - Разработка (отревьюенный код при PR из feature/F-X в develop).
* feature/F-X (от develop) - фича, или фикс бага.
* release/R-X - (от develop, когда решили релизиться, функционал зафризен, тестится, автотестится, коммитятся только фиксы). При выкатывании release/R-X вливается в main и develop. И в main на этот коммит с вливанием ставится тег.
* hotfix/H-X (от main). Вливается  обратно в main и develop.

Подходит для редких релизов (1-2 недели).
Подходит, когда идут несколько релизов (R-1, R-2) одновременно.

? Релизные ветки под команды ?



# Trunk based (есть вариации)

* trunk (main) (Часто разрешены прямые коммиты).
* part of feature или изменений одного объекта/компонента (по ООП) (от main). Важно, что ветки живут недолго (не больше 2х дней).

## Feature
* Feature flag - (возможность динамически (на лету, без перекомпиляции) включать/выключать эти изменения). В идеале даже без рестарта. Подключаются через какие-нибудь системы конфигурации.
* По умолчанию фича закрыта. Но в ветке она как бы есть. И видимо другие, кто пишут следующий код её должны учитывать. Много мелких изменений. Конфликты мелкие. И люди быстрее понимают что конфликт. Меньше конфликтного кода пишется.
* Потом тестишь с включенными фиче флагами (возможно в canary deploy).
* Потом удаляешь проверку флага. Убираешь старый код, оставляешь новый.

## Entity
* Допустим, есть сервис. У него есть интерфейс. А сам сервис подсовывается либо старый либо новый. Тоже видимо каким-то конфигом. Главное, видимо, чтобы в одном и том же сервисе сразу двух фич не пилили.

## Релизы
* Либо main, либо создаешь release/R-X от main.

Честно говоря, мне этот метод показался спорным. Поизучаю ещё.
* Непонятно что если команда большая.
* Проблему с ревью больших МР можно решить если делать коммиты атомарными.
* Проблему с множеством конфликтов лучше решать как-то процессно, чтобы куча людей одновременно с одним куском кода не работали.
* Ещё не ясно что с покрытием кода в юнит-тестах. Хоть включи, хоть выключи фиче-флаги, только половину покрытия соберешь. Придется запускать и так и так, и мержить покрытия.

## Область применения:

* Быстренько проверить как фича зашла юзеру.
* Все фиче-ветки и даже релизные (но кроме main) живут не более 2х дней.
* Дать возможность переиспользовать твой незаконченный код.

Нет веток для фич.
Ветка на изменение одной абстракции.

Если куда-то надо занести фиче-флаг, и это сходу не получается
- делается отдельный MR на поддержку переключения.
Например вводится новый интерфейс, который позволит имплементировать и старое и новое поведение и возможность переключаться.

* Continuous Code Review ??
10 минут - дедлайн на посмотреть МР.
Видимо речь скорее о парном программировании.

* Нужно очень хорошее покрытие автотестами.

=============










