

# По каким параметрам имеет смысл сравнивать подходы к ветвлению

* Подходит ли к вашей частоте деплоев/поставок.
* Сколько предыдущих релизных веток надо поддерживать.
* Частота мерж конфликтов.
* Объем работы с git при запиливании фич.
* Может ли масштабироваться с ростом команды.
* Насколько плотную совместную работу требует (парное программирование?)
* Насколько опытную команду требует. Может ли эту методику юзать команда джунов?
* Удобство при отслеживании покрытия кода при автотестах.
* Требования к покрытию кода автотестами.
* Требования к последовательности вливаний.

=============

# Git Flow

* main - Основная ветка для прода (напрямую коммиты не делаются).
* develop - Разработка (отревьюенный код при PR из feature/F-X в develop).
* feature/F-X (от develop) - фича, или фикс бага.
* release/R-X - (от develop, когда решили релизиться, функционал зафризен, тестится, автотестится, коммитятся только фиксы). При выкатывании release/R-X вливается в main и develop. И в main на этот коммит с вливанием ставится тег.
* support (для старых релизов) ?
* hotfix/H-X (от main). Вливается  обратно в main и develop.

Подходит для редких релизов (1-2 недели).
Подходит, когда идут несколько релизов (R-1, R-2) одновременно.

? Релизные ветки могут быть под команды ?

## Есть прямо расширение для поддержки git-flow

https://github.com/nvie/gitflow
Но возможно лучше понимать как все работает, чем пользоваться таким расширением.

## Мой опыт.

* Ветка develop скорее вносит путаницу.
Лучше иметь ветку release/R-X+1
* Прикольно регулярно автоматом подливать в фиче ветки
ту релизную ветку, от которой эту фиче ветку отбазировали.
Это вот реальная CI получается.

## Критика

* Нельзя применять rebase? А что, кому-то хочется в больших командах его применять?
* Много мерж конфликтов? Типа т.к. много веток. И много мержей туда-сюда. Но если подумать - можно придумать процесс вливания с сериализацией и проливом релизных веток друг в друга и в develop для минимизации конфликтов. Однако прямо CD не получится.
* Т.е. для стартапов сильно громоздок.
* Если у вас одна релизная ветка, то вроде как git flow не нужен.
* Дефолтной нужно делать develop, вместо main. Тогда само название main становится странным.

=============

# One Flow

* main
* release (?тегируется коммит на релизной ветке а не на main ?)
* feature
* hotfix ( от тега )

## PR three variants

### rebase

* Красивая линейная история.
* Но сложно ревертить.

### merge --no-ff

* Легко ревертить, отменяя мерж коммит.
* Но но когда много народа - в истории уже ничего не разберешь. В графах параллельно идут коммиты.

### rebase + merge --no-ff

* В графах коммиты идут последовательно.
* Легко ревертить.
* Сложно автоматизировать. Возможно потребуется интерактивный ребейз.

### develop + master

* Типа изначально непонятно какой тег последний отрелизился (?то ли влит в main, то ли нет?).
* Можно вводить отдельную ветку latest.
* Типа делают, что latest это main. А для бывшей main используют develop. Т.е. ветвятся от develop.
* А в конце релиза - подливаешь релизную в develop, пушишь теги, и в конце дополнительный-шаг - фаст форвардишь main (git merge --ff-only) на этот тег в develop.
* В хотфиксах тоже, - фастфорварднуть main на этот тег.

## References

https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow

=============

# Github flow

* main
* feature
* After PR merge (no ff) - **immediate deploy**.

## Принципы

* master всегда в рабочем состоянии и готов к деплою.

## См. также

Видос с плохим качеством про проблемы github flow.
https://www.youtube.com/watch?v=EwdXZXfQdQY

https://www.youtube.com/watch?v=ykZbBD-CmP8

=============

# Gitlab flow

## Environments

* Staging
* Pre-production
* Production

Вливаешь коммит в staging, staging в pre-prod, pre-prod в prod.

## References

https://docs.gitlab.com/ee/topics/gitlab_flow.html

=============


# Trunk based development (TBD)

# Область применимости:

* Нужна true Continuous Delivery. Т.е. реально изменения вливаются очень часто. Каждый час ?
* Быстренько проверить как фича зашла юзеру (A/B тесты).
* Дать возможность переиспользовать твой незаконченный код.

## Требования

* Важно, что ветки живут недолго (не больше 2х дней).
* Очень крутая команда.
* Очень крутые автотесты.
* Continuous Code Review (м.б. парное программирование).

## Ветки

* trunk (main) (Часто разрешены прямые коммиты).
* Есть вариант, когда создаешь release/R-X от main.
* part of feature или изменений одного объекта/компонента (по ООП) (от main).

## Feature
* Feature flag - (возможность динамически (на лету, без перекомпиляции) включать/выключать эти изменения). В идеале даже без рестарта. Подключаются через какие-нибудь системы конфигурации.
* По умолчанию фича закрыта. Но main она есть. И видимо другие, кто пишут следующий код её должны учитывать. Много мелких изменений. Конфликты мелкие. И люди быстрее понимают что конфликт. Меньше конфликтного кода пишется.
* Потом тестишь с включенными фиче флагами (возможно в canary deploy).
* Потом удаляешь проверку флага. Убираешь старый код, оставляешь новый.

## Entity

* Допустим, есть сервис. У него есть интерфейс. А сам сервис подсовывается либо старый либо новый. Тоже видимо каким-то конфигом. Главное, видимо, чтобы в одном и том же сервисе сразу двух фич не пилили.

### Особенности

Если куда-то надо занести фиче-флаг, и это сходу не получается
- делается отдельный MR на поддержку переключения.
Например вводится новый интерфейс, который позволит имплементировать и старое и новое поведение и возможность переключаться.


## Мои вопросы к этому:
* Если команда большая - весь код в фиче флагах?
* Какие проблемы решает, только скорость поставок? Проблему с ревью больших МР можно решить если делать коммиты атомарными.
* Проблему с множеством конфликтов лучше решать как-то процессно, чтобы куча людей одновременно с одним куском кода не работали.
* Ещё не ясно что с покрытием кода в юнит-тестах. Хоть включи, хоть выключи фиче-флаги, только половину покрытия соберешь. Придется запускать и так и так, и мержить покрытия. Это долго.

## См. также:

https://trunkbaseddevelopment.com/

=============

# Feature Branching

* main

* One branch per feature.
* Features are small
* Short delivery cycles
* Feature toggling are useful but not necessary.
*

=============

# Forking Strategy

* Forking the whole repository
* Mostly for open source

=============

# Release branching

* main
* Hotfix
* Release/X
* Release/Y
* Release/Z

* Low frequency deployments
* Backward compatibility.
* Waterfall ?
* You need to support previous releases

=============

# Environment branching

* main
* r1
* dev
* staging
* integration
* prod-r-1
* + hotfixes

=============



=============
=============
=============
=============








