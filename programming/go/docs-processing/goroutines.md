http://blog.nindalf.com/how-goroutines-work/

# Memory

При создании goroutines требует всего 2кб памяти на стек.
thread требует мегабайт.

# Start and stop

Threads при старте жрут много ресурсов, есть workaroung - thread pool.
Goroutines are created and destroyed by RT and these ops are cheap.
?? Где конкретика ?

# Switching cost.

Обычно у threads вытесняющая многозадачность. И огромный контекст.

У goroutines многозадачность кооперативная. Т.е. ф-я отдает управление когда закончится, или когда ждет объект синхронизации. 


?? Типа Преимущество кооперативной многозадачности - программист знает, что в определенном месте кода код не прервется, и нужно меньше затрат на синхронизацию.
Это если все в одном потоке. А если у нас пул потоков и две горутины могут выполняться одновременно ?






В "контекст" входят три регистра: IP, SP, DX.
(видимо и сегменты тоже).

Время на переключение не зависит от количества горутин.

# Как все работает

Есть thread pool.

В каждый момент времени один thread выполняет не более 1 горутины.

Если горутина заблокирована, её поток берет себе другую горутину.


Если горутина впадет в бесконечный цикл у go есть защита.
При вызове каждой функции рандомно вызывается скедулер.
Но если все функции в цикле инлайновые - беда.

# Блокирование

Переключение горутин может быть при:

* сетевом вводе
* сне
* операциями с каналами
* блокировке объектов синхронизации

Со стороны OS Go программа выглядит как Event Driven C program.

Якобы нет средств контролировать количество потоков.

Но можно задавать кол-во ядер. GOMAXPROCS.

=====

По возможности нужно избегать доступа к одному ресурсу из разных горутин.

=================================================



